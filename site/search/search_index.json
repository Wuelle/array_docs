{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This is a documentation of my journey to implementing a (hopefully) fast matrix library. It is less of a blog and more of a diary (meaning its primarily intended for myself to look up stuff in the future) I intend to use it for my deep learning library . There are two main folders within this project: Theory , which contains all the knowledge needed. Implementation , which contains actual implementation details in rust.","title":"Welcome"},{"location":"#welcome","text":"This is a documentation of my journey to implementing a (hopefully) fast matrix library. It is less of a blog and more of a diary (meaning its primarily intended for myself to look up stuff in the future) I intend to use it for my deep learning library . There are two main folders within this project: Theory , which contains all the knowledge needed. Implementation , which contains actual implementation details in rust.","title":"Welcome"},{"location":"Credits/","text":"Image Sources Chapter 1 Von Rjaeschke - Eigenes Werk, CC BY-SA 4.0, https://commons.wikimedia.org Chapter 2","title":"Credits"},{"location":"Credits/#image-sources","text":"Chapter 1 Von Rjaeschke - Eigenes Werk, CC BY-SA 4.0, https://commons.wikimedia.org Chapter 2","title":"Image Sources"},{"location":"useful_links/","text":"Links These are some links which i have not looked at yet, but seem pretty useful custom blas implementation convolution speedup","title":"Links"},{"location":"useful_links/#links","text":"These are some links which i have not looked at yet, but seem pretty useful custom blas implementation convolution speedup","title":"Links"},{"location":"Implementation/Chapter1/","text":"This contains the actual rust implementation of an array","title":"Chapter1"},{"location":"Theory/Chapter1/","text":"What is a matrix? A matrix is a multidimensional collection of objects. The terms \"matrix\" and \"array\" will be used interchangeably throughout the document. A matrix of size \\(m\\times{n}\\) has m rows and n columns.","title":"What is a matrix?"},{"location":"Theory/Chapter1/#what-is-a-matrix","text":"A matrix is a multidimensional collection of objects. The terms \"matrix\" and \"array\" will be used interchangeably throughout the document. A matrix of size \\(m\\times{n}\\) has m rows and n columns.","title":"What is a matrix?"},{"location":"Theory/Chapter2/","text":"How are matrices stored in memory? As mentioned before, matrices are multidimensional. Since computer memory is one-dimensional, we need to flatten the matrix. This is where strides come into play. A stride is the number of bytes between elements in memory. The array stride is usually equal to the element size. (Unless the matrix is padded) This means that a minimal array implementation contains the following data: The address of the first element The stride of the array The dimensions of the array By knowing these three things, we can computer the address of any given index. There are mainly two different ways to project a n-dimensional array into 1-dimensional space. Row-major Ordering (or \"c\" Ordering) Concatenate all the rows together. This is the common approach for high-level languages. It means that for a matrix \\(A\\) of size \\(m\\times{n}\\) with a stride of 1, the elements \\(A_{i, j}\\) and \\(A_{i, j+1}\\) are 1 byte apart and the elements \\(A_{i, j}\\) and \\(A_{i+1, j}\\) are n bytes apart. Notable languages that use Row-major Ordering are C, C++ and Java. Column-major Ordering (or \"f\" Ordering) Concatenate all columns together. This approach seems to be less popular. It means that for a matrix \\(A\\) of size \\(m\\times{n}\\) with a stride of 1, the elements \\(A_{i, j}\\) and \\(A_{i+1, j}\\) are 1 byte apart and the elements \\(A_{i, j}\\) and \\(A_{i, j+1}\\) are m bytes apart. Notable languages that use Row-major Ordering are Fortran and Julia There is no difference in performance between the two. Both provide element lookup at \\(O(1)\\) . The mapping you choose only affects implementation details, i.e you should always traverse the array row by row if you use Row-major Ordering.","title":"How are matrices stored in memory?"},{"location":"Theory/Chapter2/#how-are-matrices-stored-in-memory","text":"As mentioned before, matrices are multidimensional. Since computer memory is one-dimensional, we need to flatten the matrix. This is where strides come into play. A stride is the number of bytes between elements in memory. The array stride is usually equal to the element size. (Unless the matrix is padded) This means that a minimal array implementation contains the following data: The address of the first element The stride of the array The dimensions of the array By knowing these three things, we can computer the address of any given index. There are mainly two different ways to project a n-dimensional array into 1-dimensional space.","title":"How are matrices stored in memory?"},{"location":"Theory/Chapter2/#row-major-ordering-or-c-ordering","text":"Concatenate all the rows together. This is the common approach for high-level languages. It means that for a matrix \\(A\\) of size \\(m\\times{n}\\) with a stride of 1, the elements \\(A_{i, j}\\) and \\(A_{i, j+1}\\) are 1 byte apart and the elements \\(A_{i, j}\\) and \\(A_{i+1, j}\\) are n bytes apart. Notable languages that use Row-major Ordering are C, C++ and Java.","title":"Row-major Ordering (or \"c\" Ordering)"},{"location":"Theory/Chapter2/#column-major-ordering-or-f-ordering","text":"Concatenate all columns together. This approach seems to be less popular. It means that for a matrix \\(A\\) of size \\(m\\times{n}\\) with a stride of 1, the elements \\(A_{i, j}\\) and \\(A_{i+1, j}\\) are 1 byte apart and the elements \\(A_{i, j}\\) and \\(A_{i, j+1}\\) are m bytes apart. Notable languages that use Row-major Ordering are Fortran and Julia There is no difference in performance between the two. Both provide element lookup at \\(O(1)\\) . The mapping you choose only affects implementation details, i.e you should always traverse the array row by row if you use Row-major Ordering.","title":"Column-major Ordering (or \"f\" Ordering)"}]}